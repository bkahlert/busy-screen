#!/usr/bin/env bash

SCRIPT_DIR=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)

PREFIX=${PATCH_PREFIX-BUSYSCREEN_}
declare params_disabled=(PREFIX="$PREFIX")
# Sets variable with name $1 to the value of variable $PREFIX_$1 if it exists.
# If it doesn't, uses $2 as the default value or exits with an error message.
# Side effect: adds $PREFIX_$1=$value to the params_* arrays
p() {
    local var=${1?var missing} && shift
    local default=$1
    local prefixed=$PREFIX$var
    local resolved=${!prefixed}
    if [ "$resolved" ]; then
        printf -v "$var" '%s' "$resolved"
    elif [ "$default" ]; then
        printf -v "$var" '%s' "$default"
    else
        printf '\e[31mThe required parameter \e[3m%s\e[23m is missing.\e[0m\n' "$prefixed" >&2
        printf 'Either use \e[3m%s\e[23m or run \e[3m%s\e[23m to provide it.\n' "export $prefixed=..." "$prefixed=... ${0##*/}"
        exit 1
    fi
    local val=${!prefixed:-$default}
    printf -v "$var" '%s' "$val"
    if [ "$val" = 1 ]; then
        params_disabled+=("$prefixed=0")
    else
        params_disabled+=("$prefixed=$val")
    fi
}

# Ansible ad-hoc command wrapper which runs:
# ansible $HOST -v --become -m $1 -a "$2 $3 $4 ..."
m() {
    local module=${1?module missing} && shift
    local args="$*"
    local host
    # shellcheck disable=SC2153
    for host in $HOST; do
        ansible "$host" -v --become -m "$module" -a "$args"
    done
}

# rsync command wrapper which runs:
# rsync --recursive --compress --delete --rsh='ssh -o ConnectTimeout=120' --rsync-path='sudo rsync' "${@:1:$#-1}" "$HOST:${*: -1}"
r() {
    [ $# -ge 2 ] || {
        printf '\e[31mAt least two parameters—the files to copy, and the destination—are required\n'
        exit 1
    }
    local src=("${@:1:$#-1}")
    local host
    for host in $HOST; do
        local dst="$host:${*: -1}"
        echo "$dst"
        printf "Copying \e[3m%s\e[23m to \e[3m%s\e[23m... " "${src[*]}" "$dst"
        rsync --recursive --compress --delete --rsh='ssh -o ConnectTimeout=10' --rsync-path='sudo rsync' "${src[@]}" "$dst" || {
            printf '\e[31Failed to copy \e[3m%s\e[23m to \e[3m%s\e[23m\n' "${src[*]}" "$dst"
            exit 1
        }
        printf '\e[32;1m✔\e[0m\n'
    done
}

# ssh command wrapper which runs:
# ssh -t $HOST "$@"
s() {
    local host
    # shellcheck disable=SC2153
    for host in $HOST; do
        ssh -t "$host" "$@"
    done
}

# Runs this patch command with the same parameters as the current execution,
# but:
# - if parameter is 1, sets it to 0
# - given parameters, for example, CLI=1, overrides the corresponding parameter
continuous() {
    local env_args=("${params_disabled[@]}") paths=()
    while [ $# -gt 0 ]; do
        case $1 in
        *=*) env_args+=("${PREFIX}$1") && shift ;;
        *) break ;;
        esac
    done
    env_args+=("${PREFIX}CONTINUOUS=0")
    paths=("$@")

    local fswatch_args=(
        --recursive    # watch subdirectories
        --exclude '~$' # ignore ~ suffix temp files
        "${paths[@]}"  # paths to watch
    )

    printf '\e[2mWatching \e[3m%s\e[22;23m\n' "${paths[*]}"
    fswatch --print0 "${fswatch_args[@]}" | xargs -0 -n 1 -I {} env "${env_args[@]}" "$0"
}

deploy_cli() {
    r "$CLI_FILES/bin/busy-screen" /opt/busy-screen/bin/busy-screen
    r "$CLI_FILES/lib/" /opt/busy-screen/lib/
    r "$CLI_FILES/"*.bash /opt/busy-screen
}

deploy_server() {
    r "$SERVER_FILES/"*.bash /opt/busy-screen
    m ansible.builtin.service name=busy-screen-server state=stopped
    r "$SERVER_FILES/nodered-package.json" /opt/busy-screen/server/package.json
    r "$SERVER_FILES/flows.json" \~/busy-screen
    r "$SERVER_FILES/project-package.json" \~/busy-screen/package.json
    r "$SERVER_FILES/settings.js" \~/busy-screen
    m ansible.builtin.service name=busy-screen-server state=restarted
}

deploy_web_display() {
    declare gradle_args=()
    [ "$GRADLE_NO_DAEMON" = 0 ] || gradle_args+=(--no-daemon)
    [ "$GRADLE_CLEAN" = 0 ] || gradle_args+=(clean)
    [ "$WEB_DISPLAY" = 0 ] || gradle_args+=(jsBrowserProductionWebpack)

    if (
        cd "$GRADLE_WORKING_DIR" || exit 1
        "$GRADLE_EXE" "${gradle_args[@]}"
    ); then
        # deploy web display component
        if [ ! "$WEB_DISPLAY" = 0 ]; then
            r "$WEB_DISPLAY_FILES/"*.bash /opt/busy-screen
            r "$PROJECT_DIR/build/dist/js/productionExecutable/" /opt/busy-screen/busy-screen-web-display/
            s 'export DISPLAY=:0 && wid=$(xdotool search --sync --onlyvisible --class chromium | head -1) && xdotool windowactivate "$wid" && xdotool key ctrl+F5 || printf "Failed to find Chromium window\n"'
        fi
    fi
}

deploy_kiosk() {
    r "$KIOSK_FILES/busy-screen-kiosk" /opt/busy-screen/bin/busy-screen-kiosk
    r "$KIOSK_FILES/"*.bash /opt/busy-screen
    m ansible.builtin.service name=display-manager state=restarted
}

main() {
    # set params
    p CONTINUOUS 0                                                       # Whether to run the patch operations whenever a relevant file changes
    p HOST busy-screen.local                                             # The host to patch
    p PROJECT_DIR "${PROJECT_DIR:-$(cd "$SCRIPT_DIR/.." && pwd)}"        # The project root directory (default: parent directory of this script)
    p GRADLE_CLEAN 1                                                     # Whether to clean Gradle build directory before building (default: yes)
    p GRADLE_NO_DAEMON 1                                                 # Whether to run Gradle without daemon for building (default: yes)
    p GRADLE_EXE "$PROJECT_DIR/gradlew"                                  # The Gradle executable to use for building (default: Gradle wrapper)
    p GRADLE_WORKING_DIR "$PROJECT_DIR"                                  # The working directory for Gradle (default: project root)
    p CLI 0                                                              # Whether to update the busyscreen CLI component
    p CLI_FILES "$SCRIPT_DIR/roles/busyscreen/files"                     # The directory containing the busyscreen CLI component files
    p SERVER 1                                                           # Whether to build und update the server component
    p SERVER_FILES "$SCRIPT_DIR/roles/busyscreen_server/files"           # The directory containing the server component files
    p WEB_DISPLAY 1                                                      # Whether to build und update the web display component
    p WEB_DISPLAY_FILES "$SCRIPT_DIR/roles/busyscreen_web_display/files" # The directory containing the web display component files
    p KIOSK 1                                                            # Whether to update the kiosk component
    p KIOSK_FILES "$SCRIPT_DIR/roles/busyscreen_kiosk/files"             # The directory containing the kiosk component files

    if [ "$CLI" = 0 ] && [ "$SERVER" = 0 ] && [ "$WEB_DISPLAY" = 0 ] && [ "$KIOSK" = 0 ]; then
        local params
        printf -v params '\e[3m%s\e[23m ' "${PREFIX}HOST=foo.local" "$PREFIX...=..."
        printf '\e[1mUsage: %s %s\e[0m\n' "$params" "${0##*/}"
        printf ' Hints: Add -t / --continuous to run the corresponding patch operations whenever a relevant file changes.\n'
        printf '        Type export %sto set a different host and the appropriate option or options for the remainder of your shell session.\n' "$params"
        printf '        Check the source code for more options.\n'
        exit 2
    fi

    if [ "$CONTINUOUS" = 0 ]; then
        [ "$CLI" = 0 ] || deploy_cli
        [ "$SERVER" = 0 ] || deploy_server
        [ "$WEB_DISPLAY" = 0 ] || deploy_web_display
        [ "$KIOSK" = 0 ] || deploy_kiosk
    else
        command -v fswatch >/dev/null 2>&1 || HOMEBREW_NO_ENV_HINTS=TRUE brew install fswatch
        trap "trap - SIGTERM && kill -- -"$$ SIGINT SIGTERM EXIT
        printf 'Watching for changes... '
        printf '\e[2m%s\e[22m' 'Press Ctrl+C to stop'
        printf '\n'
        [ "$CLI" = 0 ] || continuous CLI=1 "$CLI_FILES" &
        [ "$SERVER" = 0 ] || continuous SERVER=1 "$SERVER_FILES" &
        [ "$WEB_DISPLAY" = 0 ] || continuous WEB_DISPLAY=1 "$WEB_DISPLAY_FILES" &
        [ "$KIOSK" = 0 ] || continuous KIOSK=1 "$KIOSK_FILES" &
        wait
    fi
}

main "$@"
